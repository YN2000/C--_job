# Ch10

## 10.2 six main member functions

### 10.2.3 destructor

- オブジェクト解体時に呼ばれるメンバ関数
- 処理を行わないものは暗黙的に定義される
- 再帰的に呼ばれる
    - クラスPersonのデータメンバとして、別のクラスAのオブジェクトがあるものとする。
    この時、Personオブジェクトを解体すると、そのデータメンバであるAオブジェクトも解体される。

```cpp
```

### 10.2.4 When we use destructor?

- データメンバがフリーストアに配置されるとき、デストラクタを使う必要性が生じる
    - メモリリークを防止するため、`delete pX;`等により、フリーストアに残るオブジェクト`X`を解体する必要がある
- デストラクタ内で`delete`文を実行し、利用したオブジェクトを最後に解体することがデストラクタの本来の役割

```cpp
```

- スマートポインタを利用すれば、`delete`文を書かずにオブジェクトを解体できる

```cpp
```

### 10.2.5 Resource Acquisition Is Initialization

- ポインタをデータメンバにすることには、大きな意義がある
    - 実行時に問題が発生した場合でも、ポインタが指すフリーストアのオブジェクトの解体を実行することができる。
- リソース（この場合、newで構築されたオブジェクト）をデータメンバにもつオブジェクトを構築する
    - `A`オブジェクトのためのポインタ`pA`をメンバに持つクラス`Wrapper`に、`A`オブジェクトの構築から解体までを任せる
    - 処理が途中で中断しても、`Wrapper`オブジェクトのスコープ終わりで、`~Wrapper()`が実行され、オブジェクト`A`が解体される。
- 資源獲得時初期化（Resource Acquisition Is Initialization）
    - `new`によるリソース確保はコンストラクタによる初期化時においてのみ行い、`delete`によるリソース解放は対となるデストラクタのみで行う

```cpp
```

### 10.2.6 Copy constructor

- オブジェクトをコピーして新しいオブジェクトを構築する際には、コピーコンストラクタというメンバ関数が呼ばれる
    - 何も書かなければ、暗黙的に定義される
    - 明示的にコピーコンストラクタやコピー代入演算子を定義すると、ムーブコンストラクタやムーブ代入演算子が暗黙的に定義されなくなるので、不要なコピーコンストラクタは書かない方が良い

```cpp
```

- データメンバにポインタがあるときのように、デストラクタを明示的に定義する必要がある場合、コピーコンストラクタを明示的に定義する必要がある。
- 先の例のクラスを改悪し、`name`をポインタにする
    - 暗黙的に定義されたコピーコンストラクタは、`Person A(taro)`で、`A.name = taro.name, A.age = taro.age`という処理を行う
    - しかし、前者ではアドレスがコピーされるだけなので、異なるオブジェクトが同じ文字列オブジェクトをデータメンバとして共有してしまう
    - RAIIに従い、デストラクタで文字列を解体するようにすると、`taro.name`と`A.name`という同じものを２回解体しようとするので、実行時エラーとなる

```cpp
```

- コピーコンストラクタは次のように定義される
    - 引数が`const`参照なので、パラメータの変更、引数の変更が共に不可で、リテラルを引数に取ることができる
        - これはコピーの要件に適合している？

```cpp
/*クラス名*/ (const /*クラス名*/& rhs) : /*メンバ初期化子並び*/
{
    // 文
}
```

```cpp
```

### 10.2.7 Copy assignment operator

- オブジェクトをコピーして既存のオブジェクトを上書きする際に、コピー代入演算子という、`=`で表現されるメンバ関数が呼ばれる
- 次の例を考える
    - `A`は`taro`のコピーであって参照では無いので、`taro`のデータメンバが変更されても、`A`のデータメンバは変わらない

```cpp
```

- 何も書かなければ、コピー代入演算子は暗黙的に定義される
    - コピー代入演算子とコピーコンストラクタを明示的に書くと、ムーブコンストラクタとムーブ代入演算子が暗黙的には定義されなくなるので、不要なコピー代入演算子は書かない方が良い
- データメンバにポインタがあるような、デストラクタを書く必要がある場合には、コピー代入演算子を自分で書く必要がある
    - コンパイラによって暗黙的に定義されたコピー代入演算子では、暗黙的に定義されたコピーコンストラクタと同様な問題が生じる
        - コピー元とコピー先のnameが同じオブジェクトを指してしまう
    - デストラクタを書く必要がある場合には、コピーコンストラクタとコピー代入演算子を書く必要がある

- コピー代入演算子は次のように定義する

```cpp
/*クラス名*/& operator = (const /*クラス名*/& rhs)
{
    // 文
}
```

- 例
    - 代入の両辺が同じ時は何もしなくて良いので、最初に両者のアドレスを比較する
    - 戻り値の型が`Person&`で、`*this`を返しているのは、`A = B = taro`のような式を処理するため
        - `A = (B = taro)`と、右から評価される(p.58)上で、`B = taro`の評価結果は`B`が望ましいので、代入演算子がオブジェクト自身への参照を返している
    - 古いオブジェクトが確保している資源（フリーストアのメモリ）を解放する必要があるため、コピーコンストラクタよりも複雑になっている
        - 初期化はオブジェクトを構築するだけ（コピーコンストラクタ）だが、代入は現在の値を消してから新しい値で書き換える（コピー代入演算子）

```cpp
```

### 10.2.8 ムーブ

- 例

```cpp
```

- 関数`f()`で構築されたオブジェクト`taro`は、関数の終わりで解体されそうだが、`Person A(f())`で同じオブジェクトを再構築するのは無駄なので、解体されずにムーブする。
その際に、ムーブコンストラクタというメンバ関数が呼び出される。
    - 教科書のこの様な書き方は少しmisleadingであると感じた。実験とインターネットの知識から個人的に推測した結果ではあるが、恐らく「`taro`だったもの」は解体されるが、データとしての`taro`はすでにムーブ先に移動しており、ある時点においてデータとしての`taro`は１つしか存在しないため、結果的にメモリの節約に貢献しているということではないか
- ムーブコンストラクタはコンパイラにより暗黙的に定義される
    - コピーコンストラクタ、コピー代入演算子が明示的に定義されていない場合に限る
- データメンバにポインタがあり、デストラクタを定義する必要がある場合には、暗黙的に定義されるムーブコンストラクタでは上手くいかない。
    - コピーコンストラクタ、コピー代入演算子を明示的に定義する必要があるという点においても、ムーブコンストラクタを自分で定義する必要がある。
- 必要な場面でムーブコンストラクタを書かなかった場合、メンバのサイズが大きくなると、コピーにかなりのコストがかかる
    - コンパイラによっては、「コピー消去」という最適化機能が働き、関数からオブジェクトを戻す際のコピーが省略される。

- ムーブコンストラクタの定義
    - `noexcept`は、このコンストラクタでは例外が発生しないとプログラマが考えていることを表明するもの
        - 標準ライブラリには、例外が発生しない状況でしか使われない機能があるため必要
    - 引数が右辺値参照(p.108)なので、パラメータの変更、引数の変更、引数としてリテラルを取ることが全て可能である
        - ムーブの要件に適合している？

```cpp
/*クラス名*/ (/*クラス名*/&& rhs) noexcept : /*メンバ初期化子並び*/
{
    // 文
}
```

- ムーブの例
    - ポインタ`name`を付け替えた後、古いポインタを`nullptr`にしている。
        - `f()`の終わりで`taro`（`taro`だったもの？）が解体される際の問題を解消している
        - `std::move`はムーブのための関数

```cpp
```

- `Person`をデータメンバに持つクラス`Wrappar`を考える
    - このクラスでムーブを可能にするには、`Person`が`std::move`に対応している必要がある
    - そのために、`Person`でムーブ代入演算子を定義する

```cpp
```

- ムーブ代入演算子の定義
    - ムーブコンストラクタの場合と同じ理由で、`noexcept`が必要

```cpp
/*クラス名*/& operator = (/*クラス名*/&& rhs) noexcept
{
    // 文
}
```

- 例

```cpp
```
